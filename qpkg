#!/bin/sh

# QPKG - QNX Package Manager
# Professional package management for QNX 8 ARM / BlackBerry 10
# Optimized for BB10 Term49 environment

VERSION="1.0.0"
REPO_URL="https://github.com/sw7ft/qnx-packages"
MANIFEST_URL="https://raw.githubusercontent.com/sw7ft/qnx-packages/main/packages.json"

# Use current directory for BB10 compatibility
CURRENT_DIR=$(pwd)
INSTALL_DIR="$CURRENT_DIR/qnx-packages"
CACHE_DIR="$CURRENT_DIR/.qpkg-cache"

# Colors for output (if supported)
if [ -t 1 ]; then
    RED='\033[0;31m'
    GREEN='\033[0;32m'
    YELLOW='\033[0;33m'
    BLUE='\033[0;34m'
    NC='\033[0m'
else
    RED=''
    GREEN=''
    YELLOW=''
    BLUE=''
    NC=''
fi

# Create directories
mkdir -p "$INSTALL_DIR" 2>/dev/null || {
    echo "[qpkg] Warning: Could not create $INSTALL_DIR, using current directory"
    INSTALL_DIR="$CURRENT_DIR"
}

mkdir -p "$CACHE_DIR" 2>/dev/null || {
    echo "[qpkg] Warning: Could not create cache directory, using current directory"
    CACHE_DIR="$CURRENT_DIR"
}

log() {
    printf "${BLUE}[qpkg]${NC} %s\n" "$1"
}

success() {
    printf "${GREEN}[qpkg]${NC} %s\n" "$1"
}

error() {
    printf "${RED}[qpkg]${NC} %s\n" "$1"
    exit 1
}

warn() {
    printf "${YELLOW}[qpkg]${NC} %s\n" "$1"
}

# Check if package is large (>50MB)
is_large_package() {
    size_str="$1"
    size_num=$(echo "$size_str" | sed 's/[^0-9.]//g')
    size_unit=$(echo "$size_str" | sed 's/[0-9.]//g')
    
    case "$size_unit" in
        *GB|*gb) return 0 ;;  # Always large
        *MB|*mb)
            # Check if >50MB
            if [ $(echo "$size_num > 50" | bc 2>/dev/null || echo "1") -eq 1 ]; then
                return 0
            fi
            ;;
    esac
    return 1
}

# Download package manifest
update_manifest() {
    log "Updating package manifest..."
    
    # Try curl first, then wget, then error
    if command -v curl >/dev/null 2>&1; then
        curl -L -o "$CACHE_DIR/packages.json" "$MANIFEST_URL" 2>/dev/null
        result=$?
    elif command -v wget >/dev/null 2>&1; then
        wget -O "$CACHE_DIR/packages.json" "$MANIFEST_URL" 2>/dev/null
        result=$?
    else
        error "Neither curl nor wget found. Cannot download packages."
    fi
    
    if [ $result -eq 0 ] && [ -f "$CACHE_DIR/packages.json" ]; then
        success "Package manifest updated"
    else
        error "Failed to download package manifest. Check network connection."
    fi
}

# List available packages
list_packages() {
    if [ ! -f "$CACHE_DIR/packages.json" ]; then
        update_manifest
    fi
    
    log "Available QNX packages:"
    echo
    
    # Simple JSON parsing for BB10 compatibility
    if [ -f "$CACHE_DIR/packages.json" ]; then
        # Extract package names and info
        sed -n '/"packages":/,/^  }$/p' "$CACHE_DIR/packages.json" | \
        grep -E '    "[^"]+": {' | \
        sed 's/.*"\([^"]*\)": {.*/\1/' | \
        while read pkg; do
            if [ -n "$pkg" ]; then
                # Get description and size for this package
                desc=$(sed -n "/\"$pkg\":/,/^    }/p" "$CACHE_DIR/packages.json" | \
                       grep '"description":' | \
                       sed 's/.*"description": "\([^"]*\)".*/\1/')
                size=$(sed -n "/\"$pkg\":/,/^    }/p" "$CACHE_DIR/packages.json" | \
                       grep '"size":' | \
                       sed 's/.*"size": "\([^"]*\)".*/\1/')
                
                # Mark large packages
                if is_large_package "$size"; then
                    printf "  ${GREEN}%-12s${NC} - %s (${RED}%s${NC} ${YELLOW}LARGE${NC})\n" "$pkg" "$desc" "$size"
                else
                    printf "  ${GREEN}%-12s${NC} - %s (${YELLOW}%s${NC})\n" "$pkg" "$desc" "$size"
                fi
            fi
        done
    else
        error "Package manifest not found"
    fi
    echo
    echo "Note: LARGE packages (>50MB) may take time to download on mobile connections."
}

# Install a package
install_package() {
    pkg_name="$1"
    
    if [ -z "$pkg_name" ]; then
        error "Package name required. Usage: qpkg install <package>"
    fi
    
    if [ ! -f "$CACHE_DIR/packages.json" ]; then
        update_manifest
    fi
    
    # Check if package exists
    if ! grep -q "\"$pkg_name\":" "$CACHE_DIR/packages.json"; then
        error "Package '$pkg_name' not found. Run 'qpkg list' to see available packages."
    fi
    
    # Extract package info using simpler parsing
    download_url=$(sed -n "/\"$pkg_name\":/,/^    }/p" "$CACHE_DIR/packages.json" | \
                   grep '"download_url":' | \
                   sed 's/.*"download_url": "\([^"]*\)".*/\1/')
    size=$(sed -n "/\"$pkg_name\":/,/^    }/p" "$CACHE_DIR/packages.json" | \
           grep '"size":' | \
           sed 's/.*"size": "\([^"]*\)".*/\1/')
    
    if [ -z "$download_url" ]; then
        error "Could not find download URL for $pkg_name"
    fi
    
    # Warn about large packages
    if is_large_package "$size"; then
        warn "⚠️  $pkg_name is a LARGE package ($size)"
        warn "This may take several minutes to download on mobile connections."
        printf "Continue? [y/N]: "
        read -r response
        case "$response" in
            [yY]|[yY][eE][sS]) ;;
            *) log "Download cancelled."; exit 0 ;;
        esac
    fi
    
    log "Installing $pkg_name ($size)..."
    log "Downloading from GitHub..."
    
    # Download package with progress
    pkg_file="$CACHE_DIR/${pkg_name}.pkg"
    
    # Check if partial download exists
    if [ -f "$pkg_file.partial" ]; then
        log "Found partial download, attempting to resume..."
        pkg_file_temp="$pkg_file.partial"
    else
        pkg_file_temp="$pkg_file"
    fi
    
    if command -v curl >/dev/null 2>&1; then
        # Use curl with progress bar for large files
        if is_large_package "$size"; then
            log "Downloading with progress indicator..."
            curl -L --progress-bar -C - -o "$pkg_file_temp" "$download_url"
        else
            curl -L -o "$pkg_file_temp" "$download_url" 2>/dev/null
        fi
        result=$?
        
        # Move partial to final if successful
        if [ -f "$pkg_file.partial" ] && [ $result -eq 0 ]; then
            mv "$pkg_file.partial" "$pkg_file"
        fi
        
    elif command -v wget >/dev/null 2>&1; then
        # Use wget with progress bar
        if is_large_package "$size"; then
            log "Downloading with progress indicator..."
            wget --progress=bar --continue -O "$pkg_file_temp" "$download_url"
        else
            wget -O "$pkg_file_temp" "$download_url" 2>/dev/null
        fi
        result=$?
        
        # Move partial to final if successful
        if [ -f "$pkg_file.partial" ] && [ $result -eq 0 ]; then
            mv "$pkg_file.partial" "$pkg_file"
        fi
    else
        error "Neither curl nor wget found. Cannot download packages."
    fi
    
    if [ $result -ne 0 ]; then
        if [ -f "$pkg_file" ]; then
            mv "$pkg_file" "$pkg_file.partial"
            warn "Download interrupted. Run the command again to resume."
        fi
        error "Failed to download $pkg_name"
    fi
    
    # Verify download completed
    if [ ! -f "$pkg_file" ]; then
        error "Download verification failed for $pkg_name"
    fi
    
    # Extract package
    pkg_dir="$INSTALL_DIR/$pkg_name"
    mkdir -p "$pkg_dir" 2>/dev/null || {
        error "Cannot create directory $pkg_dir"
    }
    
    log "Extracting $pkg_name..."
    
    # Determine archive type and extract
    case "$download_url" in
        *.tar.gz)
            if command -v tar >/dev/null 2>&1; then
                tar -xzf "$pkg_file" -C "$pkg_dir" 2>/dev/null
                extract_result=$?
            else
                error "tar command not available"
            fi
            ;;
        *.tar)
            if command -v tar >/dev/null 2>&1; then
                tar -xf "$pkg_file" -C "$pkg_dir" 2>/dev/null
                extract_result=$?
            else
                error "tar command not available"
            fi
            ;;
        *.zip)
            if command -v unzip >/dev/null 2>&1; then
                unzip -q "$pkg_file" -d "$pkg_dir" 2>/dev/null
                extract_result=$?
            else
                error "unzip command not available"
            fi
            ;;
        *)
            # Try tar.gz as default
            tar -xzf "$pkg_file" -C "$pkg_dir" 2>/dev/null
            extract_result=$?
            ;;
    esac
    
    if [ $extract_result -eq 0 ]; then
        success "$pkg_name installed successfully"
        log "Location: $pkg_dir"
        
        # Check for binaries and libraries
        has_bin=false
        has_lib=false
        
        if [ -d "$pkg_dir/bin" ]; then
            has_bin=true
        fi
        
        if [ -d "$pkg_dir/lib" ]; then
            has_lib=true
        fi
        
        # Provide comprehensive PATH setup instructions
        if [ "$has_bin" = true ] || [ "$has_lib" = true ]; then
            echo
            warn "📋 Environment Setup Required:"
            
            if [ "$has_bin" = true ]; then
                warn "Add to PATH: export PATH=\"$pkg_dir/bin:\$PATH\""
            fi
            
            if [ "$has_lib" = true ]; then
                warn "Add to LD_LIBRARY_PATH: export LD_LIBRARY_PATH=\"$pkg_dir/lib:\$LD_LIBRARY_PATH\""
            fi
            
            echo
            warn "💡 Quick setup options:"
            warn "1. Manual: Copy the export commands above"
            warn "2. Auto:   . ./qpkg-env.sh  (sets up all QPKG packages)"
            warn "3. Single: export PATH=\"$pkg_dir/bin:\$PATH\""
            if [ "$has_lib" = true ]; then
                warn "           export LD_LIBRARY_PATH=\"$pkg_dir/lib:\$LD_LIBRARY_PATH\""
            fi
        fi
        
        # Show available executables
        if [ "$has_bin" = true ]; then
            echo
            log "🚀 Available commands:"
            for exec in "$pkg_dir/bin"/*; do
                if [ -f "$exec" ] && [ -x "$exec" ]; then
                    basename_exec=$(basename "$exec")
                    log "  $basename_exec"
                fi
            done
        fi
        
        # Clean up download file after successful extraction
        rm -f "$pkg_file" 2>/dev/null
        rm -f "$pkg_file.partial" 2>/dev/null
        
    else
        error "Failed to extract $pkg_name"
    fi
}

# Remove a package
remove_package() {
    pkg_name="$1"
    
    if [ -z "$pkg_name" ]; then
        error "Package name required. Usage: qpkg remove <package>"
    fi
    
    pkg_dir="$INSTALL_DIR/$pkg_name"
    
    if [ ! -d "$pkg_dir" ]; then
        error "Package '$pkg_name' is not installed"
    fi
    
    log "Removing $pkg_name..."
    rm -rf "$pkg_dir" 2>/dev/null
    if [ $? -eq 0 ]; then
        success "$pkg_name removed successfully"
    else
        error "Failed to remove $pkg_name"
    fi
}

# Show help
show_help() {
    echo "QPKG - QNX Package Manager v$VERSION"
    echo "Professional package management for QNX 8 ARM / BlackBerry 10"
    echo
    
    # Check if qpkg is in PATH (global installation)
    if command -v qpkg >/dev/null 2>&1 && [ "$(command -v qpkg)" != "./qpkg" ]; then
        echo "Usage: qpkg <command> [options]"
        echo "   or: sh qpkg <command> [options]"
        echo "   or: ./qpkg <command> [options]"
        echo
        echo "Commands:"
        echo "  list, --list            List available packages"
        echo "  install <package>       Install a package"
        echo "  remove <package>        Remove an installed package"
        echo "  update, --update        Update package manifest"
        echo "  help, --help            Show this help message"
        echo
        echo "Examples:"
        echo "  qpkg list               # Show all available packages"
        echo "  qpkg install nano       # Install nano text editor"
        echo "  qpkg install quickjs    # Install QuickJS JavaScript engine"
        echo "  qpkg remove nano        # Remove nano text editor"
    else
        echo "Usage: sh qpkg <command> [options]"
        echo "   or: ./qpkg <command> [options]"
        echo
        echo "Commands:"
        echo "  list, --list            List available packages"
        echo "  install <package>       Install a package"
        echo "  remove <package>        Remove an installed package"
        echo "  update, --update        Update package manifest"
        echo "  help, --help            Show this help message"
        echo
        echo "Examples:"
        echo "  sh qpkg list            # Show all available packages"
        echo "  sh qpkg install nano    # Install nano text editor"
        echo "  sh qpkg install quickjs # Install QuickJS JavaScript engine"
        echo "  sh qpkg remove nano     # Remove nano text editor"
    fi
    echo
    echo "Large Package Support:"
    echo "  - Progress indicators for downloads >50MB"
    echo "  - Resume interrupted downloads automatically"
    echo "  - User confirmation for large packages"
    echo
    echo "Install directory: $INSTALL_DIR"
    echo "Repository: $REPO_URL"
}

# Main command dispatcher - handle both --flag and plain command formats
case "$1" in
    "list"|"--list"|"ls")
        list_packages
        ;;
    "install"|"--install"|"add")
        install_package "$2"
        ;;
    "remove"|"--remove"|"rm"|"uninstall")
        remove_package "$2"
        ;;
    "update"|"--update"|"refresh")
        update_manifest
        ;;
    "help"|"--help"|"-h"|"")
        show_help
        ;;
    *)
        error "Unknown command: $1. Run 'qpkg help' for usage information."
        ;;
esac 